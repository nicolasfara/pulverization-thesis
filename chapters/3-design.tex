\chapter{Design} % possible chapter for Projects
\label{chap:design}

This chapter describes the design choices and the overall architecture of the framework. \todo{Expand the introduction}

\section{Framework requirements}
\label{sec:framework-requirements}
\todo{Write the section about the project's requirements}

\section{Architectural design}
\label{sec:arch-design}

The framework is articulated in modules: each module takes into account a specific aspect of the pulverization.
The modularity of the framework enables from one side, the possibility to use only the needed modules, preventing the bloating of the project;
on the other side, modularity allows the customization of some implementations of the framework.

The two fundamentals modules of the pulverization framework are: \emph{core} and \emph{platform} which respectively defines the core concepts
of pulverization like the type of components and all the logic needed to run the pulverized system like defining the components reference,
loading the user-defined components and setup the communications between all of them.

The third module is \emph{rabbitmq-platform} which is highly dependent on the two modules described above and its purpose is to rely on
\textbf{RabbitMQ}\footnote{\textbf{RabbitMQ} is an open-source message-broker (or message-oriented-middleware) that originally implement
the \emph{AMQP} protocol and has since been extended with a plug-in architecture to support other protocols like \emph{MQTT}.} to enable
the communications between all the components.
This component manages all the low-level aspects related to communication like the connection to the broker, declaring queues and so on.

In~\Cref{fig:package-diagram} are represented all the framework's modules and the relationship between them.

\begin{figure}
    \centering
    \missingfigure[figwidth=\textwidth]{Package diagram showing the module relationship}
    \caption{Package diagram showing the modules that constitute the framework and their relationship.}
    \label{fig:package-diagram}
\end{figure}

The pulverization framework relies on a three-level architecture. Each level of the framework's architecture is designed to use the functionalities
of the layer above and makes accessible their functionalities to the layer below.

The described architecture takes with it the implicit ``one-way dependency'' where the layer below depends on the layer above and not vice versa.
The~\Cref{fig:framework-architecture} depicts the architecture's choice made to design and build the framework.

\begin{figure}
    \centering
    \missingfigure[figwidth=\textwidth]{Create a pyramid diagram showing the architecture of the framework emphasizing the grow-up dependency}
    \caption{Architectural diagram showing how the pulverization framework is designed.}
    \label{fig:framework-architecture}
\end{figure}

Since this is a framework, it will likely be used by several users; therefore, it is strategic to minimize the cognitive effort that the user will
have to make to use it.

For a framework to be successful and usable, it must be able to provide an incremental approach to its use,
meaning that it must provide only the abstractions necessary for its use while at the same time providing clarity in its innermost components so that
the user can understand how it works and possibly extend the framework with external modules.

The ``pyramid architecture'' used by the framework tries to apply the concept described above (\Cref{fig:pyramid-user-knowledge}):
the tip of the pyramid represents the components' abstraction defined by the pulverization and those components are used and built by the user.
Those abstraction needs to be as clear as possible from a software engineering perspective.
As you move down the pyramid, the complexity of the modules increases but the user's knowledge of them should decrease.

\begin{figure}
    \centering
    \missingfigure[figwidth=\textwidth]{pyramid architecture comparing the increase of complexity going down the pyramid and the decrease of user's knowledge going up the pyramid.}
    \caption{A correlation between the framework's complexity and the required user's knowledge to use the framework.}
    \label{fig:pyramid-user-knowledge}
\end{figure}

By designing the framework in this way, we open up different usage scenarios such as a basic use that requires only an understanding of the
basic concepts, to advanced uses that require a deep understanding of the framework but enable its complete usage and extension.

\todo{valutare se espandere qui con esempi o altro}

The sections below will describe the architectural choices made for each framework's module.

\subsection{Core module}
\label{sec:core-module}

Architecturally, the \emph{core} module is rather simple. Its simplicity is a consequence of the fact that this module is the main entry point
for the user, and the lower the complexity of this module, the faster the user can become familiar with the framework.
Moreover, a correct design of the interfaces defined in the \emph{core} module is a crucial aspect to consider to be aligned with the
pulverization concepts illustrated in the article~\cite{fi12110203}.

The pulverization represents a device as the combination of five components: \textbf{state}, \textbf{behaviour}, \textbf{communication},
\textbf{sensors} and \textbf{actuators}~\cite{fi12110203}.
The pulverization framework models the five components defined above through interfaces that the user will implement based on the specific scenario.

This module provides a DSL to generate the configuration needed for the platform to run. In particular, the DSL provides a simple, clean and handy
way to create in a declarative fashion how many logical devices should the platform manage, and how those devices are made.

\subsection{Platform module}
\label{sec:platform-module}

The platform module defines the enabling concepts for system execution like intra-component communication and provides an abstraction for
representing a remote component and how to reach it; finally, it manages all the machinery needed to run the system.

The highly distributed nature of the pulverization has forced the design phase to abstract from the actual place where components are actually
deployed; in this way, we avoid the need for the user to specify and/or manage specific aspects of deployment but can focus solely on
application logic while remaining adherent to the objectives of the pulverization, which among many want to separate aspects of 
deployment from aspects of application logic~\cite{fi12110203}.

Although the abstractions defined in this module are fundamental to the execution of the system, their understanding by the user is not essential.
Nevertheless, understanding the mechanisms defined by the platform module is important for later defining custom communicators.

As said before, communication between components is a fundamental aspect to consider; for this reason, the \emph{communicator} concept comes in.
The communicator abstracts the way how the communication between two (pulverized) components occurs, defining how two components communicate with
each other. The design of this component abstracts from the message format and the type of the involved components, effectively making the
communicator highly generic and delegating all those complexities to the platform.

Finally, the platform module provides a DSL to allow the user to instantiate the platform and then actually run the system.
The DSL allows, declaratively, to specify the components intended to be executed in that specific deployment unit, as well as indicate which
specific communicator implementation to use.

\todo{Rileggere tutta la sezione}

\subsection{Rabbitmq-platform module}
\label{sec:rabbitmq-platform-module}

This module implements a possible communicator that bases its operation on RabbitMQ. Although this module, at the time of writing, represents
the only implementation of a communicator, this does not mean that it should be the only possible solution.
Other communicators based on different technologies and infrastructures will likely be implemented in the future.

In this module, all the communication aspects that will be used for communication between components of the pulverized system are defined.
The design of the framework delegates to these types of implementations to handle low-level aspects like connections, retry on failure and so on.

While this module (or this kind of module more generally) requires a very good understanding of the concepts defined in 
section~\ref{sec:platform-module} to be implemented, it requires no cognitive effort on the part of the user to be used.
