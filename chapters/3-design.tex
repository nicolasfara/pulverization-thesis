\chapter{Design} % possible chapter for Projects
\label{chap:design}

This chapter describes the design choices and the overall architecture of the framework. \todo{Expand the introduction}

\section{Framework requirements}
\label{sec:framework-requirements}
\todo{Write the section about the project's requirements}

\section{Architectural design}
\label{sec:arch-design}

The framework is articulated in modules: each module takes into account a specific aspect of the pulverization.
The modularity of the framework enables from one side, the possibility to use only the needed modules, preventing the bloating of the project;
on the other side, modularity allows the customization of some implementations of the framework.

The two fundamentals modules of the pulverization framework are: \emph{core} and \emph{platform} which respectively defines the core concepts
of pulverization like the type of components and all the logic needed to run the pulverized system like defining the components reference,
loading the user-defined components and setup the communications between all of them.

The third module is \emph{rabbitmq-platform} which is highly dependent on the two modules described above and its purpose is to rely on
\textbf{RabbitMQ}\footnote{\textbf{RabbitMQ} is an open-source message-broker (or message-oriented-middleware) that originally implement
the \emph{AMQP} protocol and has since been extended with a plug-in architecture to support other protocols like \emph{MQTT}.} to enable
the communications between all the components.
This component manages all the low-level aspects related to communication like the connection to the broker, declaring queues and so on.

In~\Cref{fig:package-diagram} are represented all the framework's modules and the relationship between them.

\begin{figure}
    \centering
    \missingfigure[figwidth=\textwidth]{Package diagram showing the module relationship}
    \caption{Package diagram showing the modules that constitute the framework and their relationship.}
    \label{fig:package-diagram}
\end{figure}

The pulverization framework relies on a three-level architecture. Each level of the framework's architecture is designed to use the functionalities
of the layer above and makes accessible their functionalities to the layer below.

The described architecture takes with it the implicit ``one-way dependency'' where the layer below depends on the layer above and not vice versa.
The~\Cref{fig:framework-architecture} depicts the architecture's choice made to design and build the framework.

\begin{figure}
    \centering
    \missingfigure[figwidth=\textwidth]{Create a pyramid diagram showing the architecture of the framework emphasizing the grow-up dependency}
    \caption{Architectural diagram showing how the pulverization framework is designed.}
    \label{fig:framework-architecture}
\end{figure}

Since this is a framework, it will likely be used by several users; therefore, it is strategic to minimize the cognitive effort that the user will
have to make to use it.

For a framework to be successful and usable, it must be able to provide an incremental approach to its use,
meaning that it must provide only the abstractions necessary for its use while at the same time providing clarity in its innermost components so that
the user can understand how it works and possibly extend the framework with external modules.

The ``pyramid architecture'' used by the framework tries to apply the concept described above (\Cref{fig:pyramid-user-knowledge}):
the tip of the pyramid represents the components' abstraction defined by the pulverization and those components are used and built by the user.
Those abstraction needs to be as clear as possible from a software engineering perspective.
As you move down the pyramid, the complexity of the modules increases but the user's knowledge of them should decrease.

\begin{figure}
    \centering
    \missingfigure[figwidth=\textwidth]{pyramid architecture comparing the increase of complexity going down the pyramid and the decrease of user's knowledge going up the pyramid.}
    \caption{A correlation between the framework's complexity and the required user's knowledge to use the framework.}
    \label{fig:pyramid-user-knowledge}
\end{figure}

By designing the framework in this way, we open up different usage scenarios such as a basic use that requires only an understanding of the
basic concepts, to advanced uses that require a deep understanding of the framework but enable its complete usage and extension.

\todo{valutare se espandere qui con esempi o altro}

The sections below will describe the architectural choices made for each framework's module.

\subsection{Core module}
\label{sec:core-module}

Architecturally, the \emph{core} module is rather simple. Its simplicity is a consequence of the fact that this module is the main entry point
for the user, and the lower the complexity of this module, the faster the user can become familiar with the framework.
Moreover, a correct design of the interfaces defined in the \emph{core} module is a crucial aspect to consider to be aligned with the
pulverization concepts illustrated in the article~\cite{fi12110203}.

The pulverization represents a device as the combination of five components: \textbf{state}, \textbf{behaviour}, \textbf{communication},
\textbf{sensors} and \textbf{actuators}~\cite{fi12110203}.
The pulverization framework models the five components defined above through interfaces that the user will implement based on the specific scenario.

This module provides a DSL to generate the configuration needed for the platform to run. In particular, the DSL provides a simple, clean and handy
way to create in a declarative fashion how many logical devices should the platform manage, and how those devices are made.

\subsection{Platform module}
\label{sec:platform-module}

The platform module defines the enabling concepts for system execution. It then defines the concept of intra-component communication,
provides an abstraction for representing a remote component and how to access it.

The highly distributed nature of the pulverization has forced the design phase to abstract from the actual place where components are actually
deployed; in this way, we avoid the need for the user to specify and/or manage specific aspects of deployment but can focus solely on
application logic while remaining adherent to the objectives of the pulverization, which among many want to separate aspects of 
deployment from aspects of application logic.

Although the abstractions defined in this module are fundamental to the execution of the system, their understanding by the user is not essential.
Nevertheless, understanding the mechanisms defined by the platform module is important for later defining custom communicators.

The communicator abstracts the way how the communication between two (pulverized) components occurs. 
The communicator aims to define how two components communicate with each other. The design of this component abstracts from the message
format and the type of components involved, effectively making the communicator highly generic.

Its generality allows for simplified implementations, delegating to the platform the complex setup logic of the communicator such as defining which
components are involved, the message format, etc.

Finally, the platform module provides a DSL to allow the user to instantiate the platform and then actually run the system.
The DSL allows you, declaratively, to specify the components you intend to execute in that specific deployment unit, as well as indicate which
specific communicator implementation to use.
Again, the simplicity and declarativeness of the DSL are distinguishing features of this framework, simplifying its use.

\todo{Rileggere tutta la sezione}

\subsection{Rabbitmq-platform module}
\label{sec:rabbitmq-platform-module}