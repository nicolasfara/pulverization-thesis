\chapter{Design} % possible chapter for Projects
\label{chap:design}

This chapter describes the design choices and the overall architecture of the framework. \todo{Expand the introduction}

\section{Framework architecture}
\label{sec:arch-design}

The framework is articulated in modules: each module takes into account a specific aspect of the pulverization.
The modularity of the framework enables from one side, the possibility to use only the needed modules, preventing the bloating of the project;
on the other side, modularity allows the customization of some implementations of the framework.

The two fundamentals modules of the pulverization framework are: \emph{core} and \emph{platform} which respectively defines the core concepts
of pulverization like the type of components and all the logic needed to run the pulverized system like defining the components reference,
loading the user-defined components and setup the communications between all of them.

The third module is \emph{rabbitmq-platform} which is highly dependent on the two modules described above and its purpose is to rely on
\textbf{RabbitMQ}\footnote{\textbf{RabbitMQ} is an open-source message-broker (or message-oriented-middleware) that originally implement
	the \emph{AMQP} protocol and has since been extended with a plug-in architecture to support other protocols like \emph{MQTT}.} to enable
the communications between all the components.
This component manages all the low-level aspects related to communication like the connection to the broker, declaring queues and so on.

In~\Cref{fig:package-diagram} are represented all the framework's modules and the relationship between them.

\begin{figure}
	\centering
	\missingfigure[figwidth=\textwidth]{Package diagram showing the module relationship}
	\caption{Package diagram showing the modules that constitute the framework and their relationship.}
	\label{fig:package-diagram}
\end{figure}

The pulverization framework relies on a three-level architecture. Each level of the framework's architecture is designed to use the functionalities
of the layer above and makes accessible their functionalities to the layer below.

The described architecture takes with it the implicit ``one-way dependency'' where the layer below depends on the layer above and not vice versa.
The~\Cref{fig:framework-architecture} depicts the architecture's choice made to design and build the framework.

\begin{figure}
	\centering
	\missingfigure[figwidth=\textwidth]{Create a pyramid diagram showing the architecture of the framework emphasizing the grow-up dependency}
	\caption{Architectural diagram showing how the pulverization framework is designed.}
	\label{fig:framework-architecture}
\end{figure}

Since this is a framework, it will likely be used by several users; therefore, it is strategic to minimize the cognitive effort that the user will
have to make to use it.

For a framework to be successful and usable, it must be able to provide an incremental approach to its use,
meaning that it must provide only the abstractions necessary for its use while at the same time providing clarity in its innermost components so that
the user can understand how it works and possibly extend the framework with external modules.

The ``pyramid architecture'' used by the framework tries to apply the concept described above (\Cref{fig:pyramid-user-knowledge}):
the tip of the pyramid represents the components' abstraction defined by the pulverization and those components are used and built by the user.
Those abstraction needs to be as clear as possible from a software engineering perspective.
As you move down the pyramid, the complexity of the modules increases but the user's knowledge of them should decrease.

\begin{figure}
	\centering
	\missingfigure[figwidth=\textwidth]{pyramid architecture comparing the increase of complexity going down the pyramid and the decrease of user's knowledge going up the pyramid.}
	\caption{A correlation between the framework's complexity and the required user's knowledge to use the framework.}
	\label{fig:pyramid-user-knowledge}
\end{figure}

By designing the framework in this way, we open up different usage scenarios such as a basic use that requires only an understanding of the
basic concepts, to advanced uses that require a deep understanding of the framework but enable its complete usage and extension.

\todo{valutare se espandere qui con esempi o altro}

The sections below will describe the architectural choices made for each framework's module.

\subsection{Core module}
\label{sec:core-module}

Architecturally, the \emph{core} module is rather simple. Its simplicity is a consequence of the fact that this module is the main entry point
for the user, and the lower the complexity of this module, the faster the user can become familiar with the framework.
Moreover, a correct design of the interfaces defined in the \emph{core} module is a crucial aspect to consider to be aligned with the
pulverization concepts illustrated in the article~\cite{fi12110203}.

The pulverization represents a device as the combination of five components: \textbf{state}, \textbf{behaviour}, \textbf{communication},
\textbf{sensors} and \textbf{actuators}~\cite{fi12110203}.
The pulverization framework models the five components defined above through interfaces that the user will implement based on the specific scenario.

This module provides a DSL to generate the configuration needed for the platform to run. In particular, the DSL provides a simple, clean and handy
way to create in a declarative fashion how many logical devices should the platform manage, and how those devices are made.

\subsection{Platform module}
\label{sec:platform-module}

The platform module defines the enabling concepts for system execution like intra-component communication and provides an abstraction for
representing a remote component and how to reach it; finally, it manages all the machinery needed to run the system.

The highly distributed nature of the pulverization has forced the design phase to abstract from the actual place where components are actually
deployed; in this way, we avoid the need for the user to specify and/or manage specific aspects of deployment but can focus solely on
application logic while remaining adherent to the objectives of the pulverization, which among many want to separate aspects of
deployment from aspects of application logic~\cite{fi12110203}.

Although the abstractions defined in this module are fundamental to the execution of the system, their understanding by the user is not essential.
Nevertheless, understanding the mechanisms defined by the platform module is important for later defining custom communicators.

As said before, communication between components is a fundamental aspect to consider; for this reason, the \emph{communicator} concept comes in.
The communicator abstracts the way how the communication between two (pulverized) components occurs, defining how two components communicate with
each other. The design of this component abstracts from the message format and the type of the involved components, effectively making the
communicator highly generic and delegating all those complexities to the platform.

Finally, the platform module provides a DSL to allow the user to instantiate the platform and then actually run the system.
The DSL allows, declaratively, to specify the components intended to be executed in that specific deployment unit, as well as indicate which
specific communicator implementation to use.

\todo{Rileggere tutta la sezione}

\subsection{Rabbitmq-platform module}
\label{sec:rabbitmq-platform-module}

This module implements a possible communicator that bases its operation on RabbitMQ. Although this module, at the time of writing, represents
the only implementation of a communicator, this does not mean that it should be the only possible solution.
Other communicators based on different technologies and infrastructures will likely be implemented in the future.

In this module, all the communication aspects that will be used for communication between components of the pulverized system are defined.
The design of the framework delegates to these types of implementations to handle low-level aspects like connections, retry on failure and so on.

While this module (or this kind of module more generally) requires a very good understanding of the concepts defined in
section~\ref{sec:platform-module} to be implemented, it requires no cognitive effort on the part of the user to be used.

% - New section ---------------------------------------------------------------

\section{Data flow in the framework}
\label{sec:framework-data-flow}

\subsection{Components interaction}
\label{sec:framework-components-interaction}

\subsection{Device cycle}
\label{sec:framework-device-cycle}

% \todo{definire una sezione per valutare l'approccio asincrono dello scambio dati}

% \section{Framework dynamics}
% \label{sec:framework-dynamics}

% The pulverization framework is designed to adapt its behaviour based on specific configurations without the need for the user to change the
% business logic. This section will describe from a high-level perspective how the framework adapts its behaviour based on the configuration.

% One fundamental aspect of pulverization is the ability to ``move'' the component of a device from one location to another in a transparent way.

% The pulverization framework is designed to be able to take each one of the five components and set up the deployment to match the current
% configuration. The framework force the user to define the components by reasoning in terms of relations between itself and the other components,
% in this way, we isolate the single logic of the component and we can easily move it to another deployment unit if needed.
% Moreover, by defining in this way the components, the framework can easily determine if the other component is remote or in the same deployment unit,
% optimizing the communication between them.

% \begin{figure}[h]
%     \centering
%     \missingfigure[figwidth=\textwidth]{a diagram showing how easy is to move components into another deployment unit.}
%     \caption{The relation between the components of a device and the deployment unit.}
%     \label{fig:framework-dynamics}
% \end{figure}

% This feature is fundamental to cover different scenarios and contexts where a dynamic adaptation of the system is needed. For example, considering
% the case of a smart device, the system can decide to move the \emph{behaviour} from the device to a cloud service because of low batter or any other
% issues, in this way the heavy computation can be offloaded to a more powerful machine so that the device can continue to run for a longer time
% managing only aspects of sensing and actuation.

% The \Cref{fig:dynamics-example} depicts a possible scenario where the \emph{behaviour} is moved from the device to a cloud service, depending on
% the current context.
% \begin{figure}
%     \centering
%     \missingfigure[figwidth=\textwidth]{a diagram showing the example above.}
%     \caption{}
%     \label{fig:dynamics-example}
% \end{figure}

% To achieve this dynamic feature, the framework works based on two perspectives of a single component:
% \begin{itemize}
%     \item \textbf{Component implemented logic} (behaviour of the component)
%     \item \textbf{Component communication logic} (how the component communicates with the other components)
% \end{itemize}

% The first perspective is the one that the user will implement, describing and implementing the logic of the component.
% The second perspective is the one that the framework will use to determine how the communication between the components should be handled.
% Generally, the communication logic could be pre-defined by the framework, but the user can override it if needed.
% In this way, we enable full customization of the framework giving the user the ability to define how the communication between components should
% occur, or use the default implementation.

% \begin{figure}[h]
%     \centering
%     \missingfigure[figwidth=\textwidth]{a diagram showing the two perspectives of a component.}
%     \caption{}
%     \label{fig:component-perspectives}
% \end{figure}

% The~\Cref{fig:component-perspectives} shows the two perspectives of a component, the one implemented by the user and the one used by the framework.
% \todo{rileggere la sezione e vedere se ridurre il livello di dettaglio oppure introdurre nuovi concetti}
